## 章节总结 {.unlisted .unnumbered}

CPU 前端优化总结见表 {@tbl:CPU_FE_OPT}。

转换 | 如何转换？ | 为什么有用？ | 最适合于 | 由谁完成
------- | -------- | -------- | -------- | --------
基本块放置<br>(Basic block placement) | 维护热点代码 | 未取分支更便宜；更好的缓存利用率 | 任何代码，尤其是具有大量分支的代码 | 编译器
基本块对齐<br>(Basic block alignment) | 使用 NOPS 对齐移动热点代码 | 更好的缓存利用率 | 热循环 | 编译器
函数拆分<br>(Function splitting) | 将冷代码块拆分并放置在单独的函数中 | 更好的缓存利用率 | 具有复杂 CFG 的函数，当热部分之间有大块冷代码时 | 编译器
函数重新排序<br>(Function reorder)) | 将热点函数分组在一起 | 更好的缓存利用率 | 许多小型热点函数 | 链接器

表：CPU 前端优化总结。 {#tbl:CPU_FE_OPT}

* 代码布局改进经常被低估，最终被忽略和遗忘。CPU 前端性能问题，例如 I-cache 和 ITLB 未命中，浪费了大量周期，尤其是对于具有大型代码库的应用程序。但即使是小型和中型应用程序也可以从优化机器代码布局中受益。
* 当开发人员试图改善应用程序性能时，他们通常不会首先关注它。他们更喜欢从低垂的果实开始，例如循环展开和矢量化。然而，要知道仅仅通过更好的机器代码布局，您就可能获得额外的 5-10%，这仍然很有用。
* 如果您可以为您的应用程序制定一套典型用例，则通常最好使用 LTO、PGO、BOLT 和其他工具。对于大型应用程序，它是改善机器代码布局的唯一实用方法。

\sectionbreak

