## 流水线技术

流水线是使CPU快速运行的基础技术，其中多个指令在它们的执行过程中重叠。CPU中的流水线技术从汽车组装线中汲取灵感。指令的处理被分为多个阶段。这些阶段并行运行，同时处理不同指令的不同部分。DLX是由John L. Hennessy和David A. Patterson于1994年设计的一个相对简单的架构。正如[@Hennessy]中定义的那样，它具有5级流水线，包括：

1. 指令获取（IF）
2. 指令解码（ID）
3. 执行（EXE）
4. 存储访问（MEM）
5. 写回（WB）

![简单的5级流水线图。](https://raw.githubusercontent.com/dendibakh/perf-book/main/img/uarch/Pipelining.png){#fig:Pipelining width=70%}

图@fig:Pipelining显示了5级流水线CPU的理想流水线视图。在周期1中，指令x进入流水线的IF阶段。在下一个周期中，随着指令x移动到ID阶段，程序中的下一条指令进入IF阶段，依此类推。一旦流水线满了，就像上面的周期5一样，CPU的所有流水线阶段都在忙于处理不同的指令。没有流水线技术，指令`x+1`在指令`x`完成其工作之后才能开始执行。

现代高性能CPU具有多个流水线阶段，通常从10到20个或更多，具体取决于架构和设计目标。这涉及比之前介绍的简单5级流水线更复杂的设计。例如，解码阶段可能会分成几个新阶段，我们可能在执行阶段之前添加新阶段来缓冲解码指令，等等。

流水线CPU的吞吐量定义为单位时间内完成并退出流水线的指令数量。对于任何给定指令，其延迟是流水线各个阶段的总时间。由于流水线的所有阶段都彼此关联，因此每个阶段都必须准备好以锁步方式移动到下一条指令。将指令从一个阶段移动到下一个阶段所需的时间定义了CPU的基本机器周期或时钟。对于给定的流水线，所选择的时钟值由流水线中最慢的阶段定义。CPU硬件设计人员努力平衡每个阶段可以完成的工作量，因为这直接定义了CPU的操作频率。增加频率可以提高性能，通常涉及平衡和重新设计流水线以消除由最慢的流水线阶段引起的瓶颈。

在一个理想的、完全平衡且不产生任何停顿的流水线中，流水线机器中每个指令的时间由以下公式给出：
$$
\textrm{流水线机器中每条指令的时间} = \frac{\textrm{非流水线机器中每条指令的时间}}{\textrm{流水线阶段数}}
$$
在实际实现中，流水线技术引入了几个限制，限制了上述理想模型。流水线冲突阻止了理想的流水线行为，导致停顿。流水线冲突分为三类：结构冲突、数据冲突和控制冲突。幸运的是，对于程序员来说，在现代CPU中，所有类别的冲突都由硬件处理。

* **结构冲突**：由资源冲突引起。在很大程度上，它们可以通过复制硬件资源来消除，例如使用多端口寄存器或存储器。然而，消除所有这些冲突可能在硅面积和功耗方面变得非常昂贵。
* **数据冲突**：由程序中的数据依赖性引起，分为三种类型：

  * *写后读*（RAW）冲突需要依赖读取在写入之后执行。当指令`x+1`在先前的指令`x`写入源之前读取源时，就会发生这种情况，导致读取到错误的值。CPU实现了从流水线的后期阶段向前期阶段传递数据的数据转发（称为“绕道”），以减轻与RAW冲突相关的惩罚。其思想是在指令`x`完全完成之前，可以将指令`x`的结果转发到指令`x+1`。如果我们看一个例子：

  ```
  R1 = R0 ADD 1
  R2 = R1 ADD 2
  ```

  对寄存器R1存在RAW依赖。如果我们直接在添加`R0 ADD 1`完成后（从`EXE`流水线阶段），取值，我们就不需要等到`WB`阶段完成，值就会被写入到寄存器文件。绕道有助于节省一些周期。流水线越长，绕道就越有效果。

  * *读后写*（WAR）冲突需要依赖写入在读取之后执行。当指令`x+1`在指令`x`读取源之前写入源时，就会发生这种情况，导致读取到错误的新值。WAR冲突不是真正的依赖关系，可以通过一种称为[寄存器重命名](https://en.wikipedia.org/wiki/Register_renaming)[^1]的技术来消除。这是一种从物理寄存器中抽象逻辑寄存器的技术。CPU通过保留大量物理寄存器来支持寄存器重命名。逻辑寄存器（体系结构定义的寄存器）只是覆盖更广的寄存器文件上的别名。通过这种[体系结构状态](https://en.wikipedia.org/wiki/Architectural_state)[^3]的解耦，解决WAR冲突变得简单：我们只需要为写操作使用不同的物理寄存器。例如：

  ```
  R1 = R0 ADD 1
  R0 = R2 ADD 2
  ```

  对寄存器R0存在WAR依赖。由于我们有大量的物理寄存器，我们可以简单地为从写操作开始的所有`R0`寄存器的出现重新命名。一旦通过重新命名寄存器`R0`消除了WAR冲突，我们就可以以任何顺序安全地执行这两个操作。

  * *写后写*（WAW）冲突需要依赖写入在写入之后执行。当指令`x+1`在指令`x`写入源之前写入源时，就会发生这种情况，导致写入的顺序错误。通过寄存器重命名，可以消除WAW冲突，允许两个写入以任何顺序执行，同时保持正确的最终结果。

* **控制冲突**：由程序流程的变化引起。它们起源于对分支和其他改变程序流程的指令进行流水线处理。决定分支方向（取或不取）的分支条件在执行流水线阶段解决。因此，除非消除控制冲突，否则无法对下一条指令的提取进行流水线处理。动态分支预测和在下一节中描述的推测执行等技术用于克服控制冲突。

[^1]: 寄存器重命名 - [https://en.wikipedia.org/wiki/Register_renaming](https://en.wikipedia.org/wiki/Register_renaming)。
[^3]: 体系结构状态 - [https://en.wikipedia.org/wiki/Architectural_state](https://en.wikipedia.org/wiki/Architectural_state)。