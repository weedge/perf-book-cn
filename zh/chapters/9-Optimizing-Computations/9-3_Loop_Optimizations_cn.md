## 循环优化

循环是几乎所有高性能程序的核心。由于循环代表了执行大量次的代码片段，因此它们是执行时间花费最多的部分。在这样一个关键代码段进行微小的更改可能会对程序的性能产生重大影响。这就是为什么仔细分析程序中热点循环的性能并了解改进它们的可能方法非常重要。

要有效地优化循环，关键是要了解性能瓶颈。一旦找到占用大部分时间的循环，就尝试确定限制其性能的因素。通常，它将是以下一种或多种情况：内存延迟、内存带宽或机器的计算能力。Roofline 性能模型（[@sec:roofline]）是评估不同循环相对于硬件理论最大值的性能的一个良好起点。自上而下的微架构分析（[@sec:TMA]）也可以成为有关瓶颈的另一个很好的信息来源。

在本节中，我们将研究针对上述瓶颈类型最著名的循环优化。我们首先讨论低级别的优化，这些优化只会在一个循环中移动代码。此类优化通常有助于提高循环内部计算的有效性。接下来，我们将研究重构循环的高级别优化，这些优化通常会影响多个循环。第二类优化通常旨在改进内存访问，消除内存带宽和内存延迟问题。请注意，这不是所有已知循环转换的完整列表。有关下面讨论的每个转换的更详细信息，读者可以参考 [@EngineeringACompilerBook]。

编译器可以自动识别执行某些循环转换的机会。然而，有时需要开发人员干预才能达到所需的结果。在本节的第二部分，我们将分享一些有关如何发现循环优化机会的想法。了解对给定循环进行了哪些转换以及编译器未能进行哪些优化是成功性能调优的关键之一。最后，我们将考虑使用多面体框架优化循环的另一种方法。

### 低级别优化

首先，我们将考虑将代码转换为单个循环内的简单循环优化：循环不变式代码运动、循环展开、循环强度降低和循环取消交换。此类优化通常有助于提高具有高算术强度的循环的性能（请参见 [@sec:roofline]），即当循环受 CPU 计算能力限制时。通常，编译器擅长进行此类转换；但是，在某些情况下，编译器可能需要开发人员的支持。我们将在后续部分讨论这个问题。

**循环不变式代码运动 (LICM)**：在循环中评估且从未改变的表达式称为循环不变式。由于它们的价值不会跨循环迭代而改变，我们可以将循环不变式表达式移出循环。我们通过将结果存储在临时变量中并在循环内部使用它来实现这一点（请参见 [@lst:LICM]）。如今，所有优秀的编译器在大多数情况下都能成功执行 LICM。

代码清单:循环不变的代码运动
~~~~ {#lst:LICM .cpp}
for (int i = 0; i < N; ++i)             for (int i = 0; i < N; ++i) {
  for (int j = 0; j < N; ++j)    =>       auto temp = c[i];
    a[j] = b[j] * c[i];                   for (int j = 0; j < N; ++j)
                                            a[j] = b[j] * temp;
                                        }
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

**循环展开 (Loop Unrolling)**：循环变量是在循环中其值是循环迭代次数的函数的变量。例如，`v = f(i)`，其中 `i` 是迭代次数。在每次迭代中修改归纳变量可能是不必要的并且代价高昂。相反，我们可以展开循环并为归纳变量的每个增量执行多次迭代（请参见 [@lst:Unrol]）。

代码清单:循环展开
~~~~ {#lst:Unrol .cpp}
for (int i = 0; i < N; ++i)             for (int i = 0; i+1 < N; i+=2) {
  a[i] = b[i] * c[i];          =>         a[i]   = b[i]   * c[i];
                                          a[i+1] = b[i+1] * c[i+1];
                                        }
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

循环展开的主要好处是每次迭代执行更多的计算。在每个迭代结束时，索引值必须递增、测试，并且如果还有更多迭代要处理，则控制权回到循环顶部。这项工作可以看作是循环的“税收”，可以减少。通过将 [@lst:Unrol] 中的循环展开 2 倍，我们可以将执行的比较和分支指令数量减少一半。

循环展开是一种众所周知的优化；然而，许多人仍然对此感到困惑并尝试手动展开循环。我建议任何开发人员都不要手动展开任何循环。首先，编译器非常擅长这样做，并且通常可以最佳地进行循环展开。第二个原因是，处理器由于其乱序推测执行引擎而具有“嵌入式展开器”（参见 [@sec:uarch]）。当处理器等待来自第一个迭代的长时间延迟指令完成（例如加载、除法、微代码指令、长依赖链）时，它将推测性地开始执行来自第二个迭代的指令，并且只等待循环携带的依赖性。这扩展到多个迭代之前，有效地在指令重新排序缓冲区 (ROB) 中展开循环。

**循环强度降低 (LSR)**：用更便宜的指令替换昂贵的指令。此类转换可以应用于所有使用归纳变量的表达式。强度降低经常应用于数组索引。编译器通过分析变量值如何在循环迭代中演变来执行 LSR。在 LLVM 中，它被称为标量演化 (SCEV)。在 [@lst:LSR] 中，编译器相对容易证明内存位置 `b[i*10]` 是循环迭代次数 `i` 的线性函数，因此它可以用更便宜的加法替换昂贵的乘法。

代码清单:循环强度降低
~~~~ {#lst:LSR .cpp}
for (int i = 0; i < N; ++i)             int j = 0;
  a[i] = b[i * 10] * c[i];      =>      for (int i = 0; i < N; ++i) {
                                          a[i] = b[j] * c[i];
                                          j += 10;
                                        }
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

**循环取消交换 (Loop Unswitching)**：如果循环内部有一个条件语句并且它是不可变的，我们可以将其移出循环。我们通过复制循环主体并将其一个版本放置在条件语句的每个 `if` 和 `else` 子句中来实现这一点（参见 [@lst:Unswitch]）。虽然循环取消交换可能会使编写代码的数量翻倍，但每个新循环现在都可以单独优化。

代码清单:循环取消交换
~~~~ {#lst:Unswitch .cpp}
for (i = 0; i < N; i++) {               if (c)
  a[i] += b[i];                           for (i = 0; i < N; i++) {
  if (c)                       =>           a[i] += b[i];
    b[i] = 0;                               b[i] = 0;
}                                         }
                                        else
                                          for (i = 0; i < N; i++) {
                                            a[i] += b[i];
                                          }
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

### 高级优化

还有一类循环转换会改变循环的结构，并且通常会影响多个嵌套循环。我们将研究循环交换、循环块化（切分）和循环融合和分配（裂变）。这套转换旨在改进内存访问并消除内存带宽和内存延迟瓶颈。从编译器的角度来看，证明此类转换的合法性并证明其性能收益是非常困难的。从这个意义上说，开发人员处于更有利的位置，因为他们只需要关心他们特定代码片段中转换的合法性，而不必关心可能发生的每种情况。不幸的是，这也意味着我们通常必须手动进行此类转换。

**循环交换**：是交换嵌套循环循环顺序的过程。内循环使用的归纳变量切换到外循环，反之亦然。[@lst:Interchange] 显示了交换嵌套循环 `i` 和 `j` 的示例。循环交换的主要目的是对多维数组的元素进行顺序内存访问。通过遵循元素在内存中布局的顺序，我们可以提高内存访问的空间局部性，使我们的代码更加缓存友好。此转换有助于消除内存带宽和内存延迟瓶颈。

代码清单:循环交换
~~~~ {#lst:Interchange .cpp}
for (i = 0; i < N; i++)                 for (j = 0; j < N; j++)
  for (j = 0; j < N; j++)          =>     for (i = 0; i < N; i++)
    a[j][i] += b[j][i] * c[j][i];           a[j][i] += b[j][i] * c[j][i];
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

仅当循环是 *完美嵌套* 时，循环交换才是合法的。完美嵌套的循环是所有语句都在最内层循环中的循环。交换不完美的循环嵌套更难做到，但仍然可行，请查看 Codee: [https://www.codee.com/catalog/glossary-perfect-loop-nesting/](https://www.codee.com/catalog/glossary-perfect-loop-nesting/)[^1] 目录中的示例。

**循环阻塞（切分）(Loop Blocking (Tiling))**：这种转换的思想是将多维执行范围拆分为更小的块（块或切片），以便每个块都能适合 CPU 缓存。如果一个算法使用大型多维数组并对其元素执行跨步访问，则很有可能缓存利用率低下。每次这样的访问都可能将将来会被请求的数据从缓存中推出（缓存逐出）。通过将算法划分为较小的多维块，我们可以确保循环中使用的数据在重用之前保留在缓存中。

在 [@lst:blocking] 中显示的示例中，算法对数组 `a` 的元素执行行主遍历，同时对数组 `b` 执行列主遍历。循环嵌套可以划分为更小的块，以最大限度地重用数组 `b` 中的元素。

代码清单:阻塞循环
~~~~ {#lst:blocking .cpp}
// linear traversal                     // traverse in 8*8 blocks
for (int i = 0; i < N; i++)             for (int ii = 0; ii < N; ii+=8)
  for (int j = 0; j < N; j++)    =>      for (int jj = 0; jj < N; jj+=8)
    a[i][j] += b[j][i];                   for (int i = ii; i < ii+8; i++)
                                           for (int j = jj; j < jj+8; j++)
                                            a[i][j] += b[j][i];
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

循环阻塞是优化通用矩阵乘法 (GEMM) 算法的众所周知的方法。它可以提高内存访问的缓存重用率，并改善算法的内存带宽和内存延迟。

通常，工程师会针对每个 CPU 核心专有的缓存大小（英特尔和 AMD 的 L1 或 L2，Apple 的 L1）优化平铺算法。然而，专用缓存的大小会随着每一代发生变化，因此硬编码块大小会带来其自身的挑战。作为替代解决方案，可以使用 cache-oblivious: [https://en.wikipedia.org/wiki/Cache-oblivious_algorithm](https://en.wikipedia.org/wiki/Cache-oblivious_algorithm)[^2] 算法，其目标是在任何缓存大小下都能合理地工作。

**循环融合和分配 (裂变) (Loop Fusion and Distribution (Fission))**：当单独的循环迭代相同范围并且不引用彼此的数据时，可以将它们融合在一起。[@lst:fusion] 显示了循环融合的示例。相反的过程称为循环分配 (裂变)，即循环被分成单独的循环。

代码清单:循环融合和分配
~~~~ {#lst:fusion .cpp}
for (int i = 0; i < N; i++)             for (int i = 0; i < N; i++) {
  a[i].x = b[i].x;                        a[i].x = b[i].x;
                               =>         a[i].y = b[i].y;
for (int i = 0; i < N; i++)             }
  a[i].y = b[i].y;                      
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

循环融合有助于降低循环开销（类似于循环展开），因为两个循环都可以使用相同的归纳变量。此外，循环融合还可以帮助改善内存访问的时间局部性。在 [@lst:fusion] 中，如果结构体的 `x` 和 `y` 成员恰好位于同一个缓存线上，那么最好将两个循环融合，因为我们可以避免两次加载相同的缓存线。这将减少缓存占用并提高内存带宽利用率。

但是，循环融合并不总是能提高性能。有时，将循环拆分为多个通道、预过滤数据、排序和重新组织数据等会更好。通过将大型循环分配到多个更小的循环中，我们可以限制每个循环迭代所需的数据量，有效地提高内存访问的时间局部性。这有助于出现高缓存争用情况，通常发生在大循环中。循环分配还可以减少寄存器压力，因为每个循环迭代中执行的操作更少。此外，将大循环分解成多个较小的循环可能会因更好的指令缓存利用率而有利于 CPU 前端的性能。最后，分布后，每个小循环都可以由编译器进一步单独优化。

**循环展开和卡住 (Loop Unroll and Jam)**：要执行此转换，需要首先展开外循环，然后将多个内循环组合在一起，如 [@lst:unrolljam] 所示。此转换增加了内循环的 ILP（指令级并行性），因为内循环中执行了更多独立的指令。在代码示例中，内循环是一个归约操作，它累积数组 `a` 和 `b` 元素之间的差值。当我们将循环嵌套展开和卡住 2 倍时，我们实际上同时执行初始外循环的 2 次迭代。这一点通过具有 2 个独立的累加器来强调，它打破了初始变体中 `diffs` 上的依赖链。

代码清单:循环展开和阻塞
~~~~ {#lst:unrolljam .cpp}
for (int i = 0; i < N; i++)           for (int i = 0; i+1 < N; i+=2)
  for (int j = 0; j < M; j++)           for (int j = 0; j < M; j++) {
    diffs += a[i][j] - b[i][j];   =>      diffs1 += a[i][j]   - b[i][j];
                                          diffs2 += a[i+1][j] - b[i+1][j];
                                        }
                                      diffs = diffs1 + diffs2;
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
当外循环没有跨迭代依赖关系时，可以执行循环展开和卡住，换句话说，内循环的两次迭代可以并行执行。此外，当内循环具有与外循环索引（例如此处的 `i`）步进的内存访问时，这种转换才有意义，否则其他转换可能更适用。循环展开和卡住尤其适用于内循环执行次数较少的情况，例如少于 4 次。通过执行此转换，我们将更多的独立操作打包到内循环中，从而提高 ILP（指令级并行性）。

有时，循环展开和卡住转换对于外循环矢量化非常有用，而矢量化在撰写本文时编译器还无法自动完成。当编译器看不到内循环的执行次数时，它仍然可以矢量化原始内循环，希望它执行足够的迭代次数以命中矢量化代码（有关矢量化的更多信息，请参见下一部分）。但是，如果执行次数很少，程序将使用循环的慢速标量版本。一旦执行循环展开和卡住，我们允许编译器以不同的方式矢量化代码：现在将内循环中的独立指令“粘合”在一起（也称为 SLP 矢量化）。

### 发现循环优化机会

正如我们在本节开头所讨论的，编译器将负责优化循环的繁重工作。您可以依靠它们对循环代码进行所有明显的改进，例如消除不需要的工作、执行各种窥孔优化等。有时编译器足够聪明，可以默认生成快速版本的循环，而其他时候我们必须自己进行一些重写来帮助编译器。正如我们之前所说，从编译器的角度来看，合法且自动地进行循环转换是非常困难的。通常，当编译器无法证明转换的合法性时，它们必须保守。

考虑 [@lst:Restrict] 中的代码。编译器无法将表达式 `strlen(a)` 移出循环体外。因此，循环每次迭代都会检查是否到达字符串结尾，这显然很慢。编译器无法提升调用的原因是，数组 `a` 和 `b` 的内存区域可能重叠。在这种情况下，将 `strlen(a)` 移出循环体外是非法的。如果开发人员确信内存区域不会重叠，他们可以使用 `restrict` 关键字声明函数 `foo` 的两个参数，即 `char* __restrict__ a`。


代码清单:不能将strlen移出循环
~~~~ {#lst:Restrict .cpp}
void foo(char* a, char* b) {
  for (int i = 0; i < strlen(a); ++i)
    b[i] = (a[i] == 'x') ? 'y' : 'n';
}
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

正如我们在本节开头讨论的那样，编译器将负责优化循环的繁重工作。您可以依靠它们对循环代码进行所有明显的改进，例如消除不需要的工作、进行各种窥孔优化等。有时编译器足够聪明，可以默认生成快速版本的循环，而其他时候我们必须自己进行一些重写来帮助编译器。正如我们之前所说，从编译器的角度来看，合法且自动地进行循环转换是非常困难的。通常，当编译器无法证明转换的合法性时，它们必须保守。

以下是一些有关如何自己发现循环优化机会的提示：

* **找到热点循环**: 使用性能分析器识别占用大量执行时间的循环。首先关注优化这些循环。
* **分析循环结构**: 了解循环内部执行的操作类型、内存访问模式和循环执行次数。这将帮助您识别可能有利的循环转换类型。
* **不要害怕尝试**: 有时，找到最佳循环转换的最好方法是尝试不同的方法并找出效果最好的方法。有许多不同的循环优化技术可用，所以不要害怕尝试找到适合您特定情况的技术。
* **寻找编译器提示**: 一些编译器提供提示或警告，可以帮助您识别潜在的循环优化机会。例如，编译器可能会警告您一个可以矢量化的循环。

请记住，循环优化既是一门艺术，也是一门科学。没有一刀切的解决方案，优化循环的最佳方法是进行试验并找出最适合您的特定情况的方法。

### 循环优化框架

多年来，研究人员开发了确定循环转换合法性和自动转换循环的技术。其中一项发明是 多面体框架: [https://en.wikipedia.org/wiki/Loop_optimization#The_polyhedral_or_constraint-based_framework](https://en.wikipedia.org/wiki/Loop_optimization#The_polyhedral_or_constraint-based_framework)[^3]。GRAPHITE: [https://gcc.gnu.org/wiki/Graphite](https://gcc.gnu.org/wiki/Graphite)[^4] 是最早集成到生产编译器中的多面体工具之一。GRAPHITE 基于从 GCC 的低级中间表示 GIMPLE 提取的多面体信息，执行一系列经典循环优化。GRAPHITE 证明了该方法的可行性。

后来，LLVM 编译器开发了自己的多面体框架，称为 Polly: [https://polly.llvm.org/](https://polly.llvm.org/)[^5]。Polly 是 LLVM 的高级循环和数据局部性优化基础架构。它使用基于整数多面体的抽象数学表示来分析和优化程序的内存访问模式。Polly 执行经典循环转换，尤其是切分和循环融合，以改善数据局部性。该框架在许多著名的基准测试上显示了显著的加速 [@Grosser2012PollyP]。下面是一个例子，说明 Polly 如何将来自 Polybench 2.0: [https://web.cse.ohio-state.edu/~pouchet.2/software/polybench/](https://web.cse.ohio-state.edu/~pouchet.2/software/polybench/)[^6] 基准套件的通用矩阵乘法 (GEMM) 内核的运行速度提高了近 30 倍：

```bash
$ clang -O3 gemm.c -o gemm.clang
$ time ./gemm.clang
real 0m6.574s
$ clang -O3 gemm.c -o gemm.polly -mllvm -polly
$ time ./gemm.polly
real 0m0.227s
```

Polly 是一个强大的循环优化框架；但是，它仍然会错过一些常见和重要的情况。[^7] 它没有启用 LLVM 基础架构中的标准优化管道，并且要求用户提供显式编译器选项才能使用它 (`-mllvm -polly`)。在寻找加速循环的方法时，使用多面体框架是一个可行的选择。

[^1]: Codee: 完美循环嵌套 - [[https://www.codee.com/catalog/glossary-perfect-loop-nesting/](https://www.codee.com/catalog/glossary-perfect-loop-nesting/)]]([https://www.codee.com/catalog/glossary-perfect-loop-nesting/](https://www.codee.com/catalog/glossary-perfect-loop-nesting/))
[^2]: 缓存遗忘算法 - [https://en.wikipedia.org/wiki/Cache-oblivious_algorithm](https://en.wikipedia.org/wiki/Cache-oblivious_algorithm)
[^3]: 多面体框架 - [https://en.wikipedia.org/wiki/Loop_optimization#The_polyhedral_or_constraint-based_framework](https://en.wikipedia.org/wiki/Loop_optimization#The_polyhedral_or_constraint-based_framework).
[^4]: GRAPHITE 多面体框架 - [https://gcc.gnu.org/wiki/Graphite](https://gcc.gnu.org/wiki/Graphite).
[^5]: Polly - [https://polly.llvm.org/](https://polly.llvm.org/).
[^6]: Polybench - [https://web.cse.ohio-state.edu/~pouchet.2/software/polybench/](https://web.cse.ohio-state.edu/~pouchet.2/software/polybench/).
[^7]: Why not Polly? - [https://sites.google.com/site/parallelizationforllvm/why-not-polly](https://sites.google.com/site/parallelizationforllvm/why-not-polly).
